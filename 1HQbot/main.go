package main

import (
	"time"
	"os/exec"
	"github.com/go-vgo/robotgo"
	"fmt"
	"io/ioutil"
	"net/http"
	"regexp"
	"strings"
	"bytes"
	"strconv"
)

func main() {
	//time.Sleep(2000 * time.Millisecond)
	//getStarted()
	//takeScreenShot()
	//cropScreenshot(getScreensNames())
	time.Sleep(1000 * time.Millisecond)
	cmd := "tesseract ~/Desktop/pic.png ~/Desktop/text"
	tesseract := exec.Command("bash", "-c", cmd)
	tesseract.Run()
	question, answers := getQandA()
	url1 := "https://www.google.com/search?q=" + makeURL(question) + "%20" + makeURL(answers[0])
	url2 := "https://www.google.com/search?q=" + makeURL(question) + "%20" + makeURL(answers[1])
	url3 := "https://www.google.com/search?q=" + makeURL(question) + "%20" + makeURL(answers[2])
	url := []string{url1, url2, url3}
	jargon := "The correct choice is: "
	fmt.Print(jargon)
	fmt.Println(googlinTimeResult(url))
}

func takeScreenShot() {
	arr := []string{"shift", "command"}
	robotgo.KeyTap("numpad_3", arr) // takes screen shot for tesseract
}

func cropScreenshot(name string) {
	//convert pic.png -crop 700x700+915+300 pic2.png
	cmd := "convert ~/Desktop/" + name
	cmd += " -crop 700x700+915+300 ~/Desktop/pic.png"
	crop := exec.Command("bash", "-c", cmd)
	crop.Run()
}

func getStarted() {
	quickTime := exec.Command("bash", "-c", "open /Applications/QuickTime\\ Player.app/")
	quickTime.Run()
	//...///
}

func getScreensNames() string {
	getName := exec.Command("bash", "-c", "ls ~/Desktop")
	gotNames, _ := getName.Output()
	//fmt.Print(string(gotNames))
	nameString := string(gotNames)
	var name1 [100]string
	i := 0
	for _, r := range nameString {
		c := string(r)
		name1[i] = c
		i++
	}
	// THIS IS HARDCODED FOR THE SCREENSHOT NAMES GENERATED BY MAC SHIFT COMMAND 3
	var name2 [50]string
	for i := 0; i < 6; i++ {
		name2[i] = name1[i]
	}
	name2[7] = "\\"
	name2[8] = " "
	for i := 9; i < 13; i++ {
		name2[i] = name1[i - 2]
	}
	name2[14] = "\\"
	name2[15] = " "
	for i := 16; i < 26; i++ {
		name2[i] = name1[i - 4]
	}
	name2[27] = "\\"
	name2[28] = " "
	for i := 29; i < 31; i++ {
		name2[i] = name1[i - 6]
	}
	name2[32] = "\\"
	name2[33] = " "
	for i := 34; i < 41; i++ {
		name2[i] = name1[i - 8]
	}
	name2[42] = "\\"
	name2[43] = " "
	for i := 44; i < 50; i++ {
		name2[i] = name1[i - 10]
	}
	//fmt.Println(name2)
	var picName string
	for i := 0; i < 50; i++ {
		picName += name2[i]
	}
	//fmt.Println(picName)
	return picName
}

func getQandA() ([]byte, [][]byte) {
	b, err := ioutil.ReadFile("/Users/TheChosenOne/Desktop/text.txt") // just pass the file name
	if err != nil {
		fmt.Print(err)
	}
	//fmt.Println(b) // print the content as 'bytes'
		//str := string(b) // convert content to a 'string'
		//fmt.Println(str) // print the content as a 'string'
	question := make([]byte, len(b))
	var placeHolder int
	for i := 0; i < 100; i++ {
		if b[i] == 10 {
			question[i] = ' '
			continue
		}
		question[i] = b[i]
		if b[i] == 63 { // 63 is question mark in ascii
			placeHolder = i + 3  // plus two to skip the new lines
			break
		}
	}
	//strQuestion := string(question) // puts the question in a string
	//fmt.Println(strQuestion)

	answer1 := make([]byte, len(b))
	for i := 0; i < 100; i++ {
		if b[placeHolder] == 10 { // 10 is new line in ascii
			if answer1[1] == 0 {
				placeHolder++
				continue
			}
			placeHolder++
			break
		}
		answer1[i] = b[placeHolder]
		placeHolder++
	}
	//theAnswer1 := string(answer1)
	//fmt.Println(theAnswer1)
	answer1 = bytes.Trim(answer1, "\x00")

	answer2 := make([]byte, len(b))
	for i := 0; i < 100; i++ {  //placeHolder + 2 because there are two 10's which are new lines
		if b[placeHolder] == 10 { // 10 is new line in ascii
			if answer2[1] == 0 {
				placeHolder++
				continue
			}
			placeHolder++
			break
		}
		answer2[i] = b[placeHolder]
		placeHolder++
	}
	//theAnswer2 := string(answer2)
	//fmt.Println(theAnswer2)

	answer3 := make([]byte, len(b))
	for i := 0; i < 100; i++ { //placeHolder + 2 because there are two 10's which are new lines
		if b[placeHolder] == 10 { // 10 is new line in ascii
			if answer3[1] == 0 {
				placeHolder++
				continue
			}
			placeHolder++
			break
		}
		answer3[i] = b[placeHolder]
		placeHolder++
	}
	//theAnswer3 := string(answer3)
	//fmt.Println(theAnswer3)
	question = bytes.Trim(question, "\x00")
	answer1 = bytes.Trim(answer1, "\x00")
	answer2 = bytes.Trim(answer2, "\x00")
	answer3 = bytes.Trim(answer3, "\x00")

	answers := [][]byte{answer1, answer2, answer3}
	//answers := []string{theAnswer1, theAnswer2, theAnswer3}
	return question, answers
}

func googlinTimeResult(url []string) int {
	var results [3]int
	for i := 0; i < 3; i++ {
		resp, _ := http.Get(url[i])
		bytes, _ := ioutil.ReadAll(resp.Body)
		resp.Body.Close()
		s := string(bytes)
		r, _ := regexp.Compile("id=\"resultStats.*results")
		s = r.FindString(s)
		var k string
		for i := 0; i < len(s); i++{
			if '0' <= s[i] && s[i] <= '9' {
				k += string(s[i])
			}
		}
		results[i], _ = strconv.Atoi(k)
	}
	if results[0] > results[1] {
		if results[0] > results[2] {
			return 1 //results[0]
		} else {
			return 3 //results[2]
		}
	} else {
		if results[1] > results[2] {
			return 2 //results[1]
		} else {
			return 3 //results[2]
		}
	}
}

func makeURL(question []byte) string {
	newQuestion := make([]byte, len(question) + 100)
	questionUp := 0
	for i := 0; i < len(question); i++ {
		if question[i] == 32 {
			newQuestion[questionUp] = '%'
			newQuestion[questionUp + 1] = '2'
			newQuestion[questionUp + 2] = '0'
			questionUp = questionUp + 3
			continue
		}
		newQuestion[questionUp] = question[i]
		questionUp++
	}
	finalQuestion := string(newQuestion)
	finalQuestion = strings.Trim(finalQuestion, "\x00")
	return finalQuestion
}